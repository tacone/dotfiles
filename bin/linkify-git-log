#!/usr/bin/zsh

function get_alias_name() {
    echo ${1%%=*}
}

function get_alias_command() {
    local alias_command=${line#*=};

    #if alias is wrapped with '' then remove them
    if [[ $alias_command == *"'"* ]]; then
        alias_command=$(echo $alias_command | sed -nE "s#^'(.*)'#\1#p")
    elif [[ $alias_command == *'"'* ]]; then
        alias_command=$(echo $alias_command | sed -nE 's#^"(.*)"#\1#p')
    fi

    echo "$alias_command"
}

if [ -n "$INTERPOLATE_GIT_LOG" ]; then
    # make aliases for all git commands

    SCRIPT_DIR="$( cd "$( dirname $0 )" >/dev/null 2>&1 && pwd )"
    SCRIPT="$SCRIPT_DIR/$(basename $0)"

    # replace every git log alias with a function

    while IFS= read -r line
    do
        local alias_name=$(get_alias_name "$line")
        local alias_command=$(get_alias_command "$line")

        local short_hash_env=''

        # if the alias contains %h then it uses short hashes
        if [[ $alias_command == *'%h'* ]]; then
            # replace %h with %H
            alias_command=${alias_command//\%h/%H}
            short_hash_env='GIT_SHORT_HASH=1'
        fi

        # create a function for the alias
        local fun="function $alias_name() { $alias_command --color "\"'$@'\"" | $short_hash_env $SCRIPT; }"
        eval "$fun"
        unalias "$alias_name"
    done <<< $(alias | grep 'git log')

    # alias  | grep -i "git status" | grep -v porcelain

    return
fi

set -e # exit if it's not a git repository

function get_repository_url () {
    local remote=$1
    local platform=''
    local repo=''
    local org=''
    local project=''

    # determine the platform based on the remote URL
    if [[ $remote == *"github.com"* ]]; then
        platform="github.com"
    elif [[ $remote == *"gitlab.com"* ]]; then
        platform="gitlab.com"
    elif [[ $remote == *"ssh.dev.azure.com"* ]]; then
        platform="dev.azure.com"
    fi

    # extract the user and repo based on the platform
    if [[ $platform == "github.com" ]] || [[ $platform == "gitlab.com" ]]; then
        repo=$(echo $remote | sed -nE 's#.+:([^.]+).git#\1#p')
    elif [[ $platform == "dev.azure.com" ]]; then
        # Azure uses a different format for the repository URL
        org=$(echo $remote | cut -d/ -f2)
        project=$(echo $remote | cut -d/ -f3)
        repo=$(echo $remote | cut -d/ -f4)
    fi

    if [[ $platform == "dev.azure.com" ]]; then
        # Azure uses a different URL structure
        url="https://dev.azure.com/$org/$project/_git/$repo"
    else
        url="https://$platform/$repo"
    fi

    echo "$url"
}

function get_platform () {
    local remote=$1
    local platform=''

    # determine the platform based on the remote URL
    if [[ $remote == *"github.com"* ]]; then
        platform="github.com"
    elif [[ $remote == *"gitlab.com"* ]]; then
        platform="gitlab.com"
    elif [[ $remote == *"ssh.dev.azure.com"* ]]; then
        platform="dev.azure.com"
    fi

    echo "$platform"
}

function log () {
    local remote=$(git config --get remote.origin.url)
    local repository_url=$(get_repository_url $remote)
    local platform=$(get_platform $remote)

    # todo: handle the case where the remote is not a git repository
    #       while replacing the hash with short hash where appropriate

    # echo remote: $remote
    # echo repository_url: $repository_url
    # echo platform: $platform

    while IFS= read -r line
    do
        if [[ -z "$platform" ]]; then
            echo -e "$line"
            continue
        fi

        local hash=''

        # remove all non-printable characters
        local sanitized_line=$( tr -dc '[[:print:][:space:]]' <<< "$line")

        # extract the hash from the line
        [[ $sanitized_line =~ '^.*([0-9a-f]{40}).*' ]] && hash=${match[1]}

        # extract the short hash
        local short_hash=${hash:0:8}

        # if the line doesn't contain a hash then print it as is
        if [[ -z "$hash" ]]; then
            echo -e "$line"
            continue
        fi

        if [[ $platform == "dev.azure.com" ]]; then
            # Azure uses a different URL structure
            url="$repository_url/commit/$hash"
        else
            url="$repository_url/commit/$short_hash"
        fi

        local link_text="$hash"
        [[ $GIT_SHORT_HASH -eq 1 ]] && link_text="$short_hash"

        link=$'\e]8;;'"$url"$'\a'"$link_text"$'\e]8;;\a'

        # print the modified line
        echo -e ${line//$hash/$link}
    done
}

log | less