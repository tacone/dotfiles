#!/usr/bin/zsh


# reads global variable $__line and sets $__alias_name, $__alias_command, $alias_full_command

function parse_alias() {
    __alias_name=${__line%%=*}
    __alias_command=${__line#*=};

    # if the alias is wrapped with quotes then remove them

    if [[ $__alias_command == *"'"* ]]; then
        __alias_command=${__alias_command#\'}
        __alias_command=${__alias_command%\'}
    elif [[ $__alias_command == *'"'* ]]; then
        __alias_command=${__alias_command#\"}
        __alias_command=${__alias_command%\"}
    fi
}

function replace_alias_with () {
    eval "$1"
    unalias "$__alias_name"
}

if [ -n "$INTERPOLATE_GIT_LOG" ]; then

    # make aliases for all git commands

    SCRIPT_DIR="$( cd "$( dirname $0 )" >/dev/null 2>&1 && pwd )"
    SCRIPT="$SCRIPT_DIR/$(basename $0)"

    # replace every git log alias with a function

    while IFS= read -r __line
    do
        parse_alias

        # if the alias contains %h then it uses short hashes

        short_hash_env=''
        if [[ $__alias_command == *'%h'* ]]; then

            # replace %h with %H

            __alias_command=${__alias_command//\%h/%H}
            short_hash_env='GIT_SHORT_HASH=1'
        fi

        local cmd="$__alias_command"' --color=always "$@"'

        replace_alias_with "function $__alias_name() { $cmd | $short_hash_env $SCRIPT log; }"
    done <<< $(alias | grep 'git log')

    while IFS= read -r __line
    do
        parse_alias

        replace_alias_with "function $__alias_name() { $SCRIPT status; $__alias_command; }"
    done <<< $(alias  | grep -i "git status" | grep -v porcelain)


    return
fi

set -e # exit if it's not a git repository

function get_repository_url () {
    local remote=$1
    local platform=''
    local repo=''
    local org=''
    local project=''

    # determine the platform based on the remote URL
    if [[ $remote == *"github.com"* ]]; then
        platform="github.com"
    elif [[ $remote == *"gitlab.com"* ]]; then
        platform="gitlab.com"
    elif [[ $remote == *"ssh.dev.azure.com"* ]]; then
        platform="dev.azure.com"
    fi

    # extract the user and repo based on the platform

    if [[ $platform == "github.com" ]] || [[ $platform == "gitlab.com" ]]; then
        repo=$(echo $remote | sed -nE 's#.+:([^.]+).git#\1#p')
    elif [[ $platform == "dev.azure.com" ]]; then

        # Azure uses a different format for the repository URL

        org=$(echo $remote | cut -d/ -f2)
        project=$(echo $remote | cut -d/ -f3)
        repo=$(echo $remote | cut -d/ -f4)
    fi

    if [[ $platform == "dev.azure.com" ]]; then

        # Azure uses a different URL structure

        url="https://dev.azure.com/$org/$project/_git/$repo"
    else
        url="https://$platform/$repo"
    fi

    echo "$url"
}

function print_link() {
    local url=$1
    local link_text=$2
    local link=$'\e[94m\e]8;;'"$url"$'\a'"$link_text"$'\e]8;;\a\e[0m'
    echo -n $link
}

function get_current_branch () {
    git rev-parse --abbrev-ref HEAD
}

function print_branch_link () {
    local branch=$(get_current_branch)
    local remote=$(get_remote)
    local platform=$(get_platform $remote)
    local url=$(get_repository_url $remote)
    local link="$url/tree/$branch"
    if [[ $platform == "dev.azure.com" ]]; then

        # Azure uses a different URL structure for branches

        local link="$url?version=GB$branch"
    fi
    echo
    print_link $link "$branch on $platform"
    echo -n " [ "
    print_link $url "default branch"
    echo " ]"
    echo
}

function get_platform () {
    local remote=$1
    local platform=''

    # determine the platform based on the remote URL

    if [[ $remote == *"github.com"* ]]; then
        platform="github.com"
    elif [[ $remote == *"gitlab.com"* ]]; then
        platform="gitlab.com"
    elif [[ $remote == *"ssh.dev.azure.com"* ]]; then
        platform="dev.azure.com"
    fi

    echo "$platform"
}

function get_remote () {
    git config --get remote.origin.url
    local return_code="$?"

    # todo: make this work

    if [[ $return_code -ne 0 ]]; then
        exit $return_code
    fi
}

function log () {
    local remote=$(get_remote)
    local repository_url=$(get_repository_url $remote)
    local platform=$(get_platform $remote)

    # todo: handle the case where the remote is not a git repository
    #       while replacing the hash with short hash where appropriate

    while IFS= read -r __line
    do
        if [[ -z "$platform" ]]; then
            echo -e "$__line"
            continue
        fi

        local hash=''

        # remove all non-printable characters

        local sanitized_line=$( tr -dc '[[:print:][:space:]]' <<< "$__line")

        # extract the hash from the line

        [[ $sanitized_line =~ '^.*([0-9a-f]{40}).*' ]] && hash=${match[1]}

        # extract the short hash

        local short_hash=${hash:0:8}

        # if the line doesn't contain a hash then print it as is

        if [[ -z "$hash" ]]; then
            echo -e "$__line"
            continue
        fi

        if [[ $platform == "dev.azure.com" ]]; then

            # Azure uses a different URL structure

            url="$repository_url/commit/$hash"
        else
            url="$repository_url/commit/$short_hash"
        fi

        local link_text="$hash"
        [[ $GIT_SHORT_HASH -eq 1 ]] && link_text="$short_hash"

        link=$'\e]8;;'"$url"$'\a'"$link_text"$'\e]8;;\a' # in-lined for speed

        # print the modified line

        echo -e ${__line//$hash/$link}
    done
}

if [[ $1 == 'log' ]]; then
    log | less
elif [[ $1 == 'status' ]]; then
    print_branch_link
fi